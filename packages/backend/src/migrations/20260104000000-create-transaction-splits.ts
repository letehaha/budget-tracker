import { DataTypes, AbstractQueryInterface, Transaction } from '@sequelize/core';

/**
 * Migration to create TransactionSplits table for split transaction feature.
 * This table stores additional category splits for transactions (primary category remains in Transactions.categoryId).
 * Also adds splitId column to RefundTransactions to allow refunds to target specific splits.
 */
module.exports = {
  up: async (queryInterface: AbstractQueryInterface): Promise<void> => {
    const t: Transaction = await queryInterface.sequelize.startUnmanagedTransaction();

    try {
      // Create TransactionSplits table
      await queryInterface.createTable(
        'TransactionSplits',
        {
          id: {
            type: DataTypes.UUID,
            primaryKey: true,
            allowNull: false,
            // UUIDv7 is generated by the Sequelize model's BeforeCreate hook
          },
          transactionId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
              table: 'Transactions',
              key: 'id',
            },
            onUpdate: 'CASCADE',
            onDelete: 'CASCADE',
          },
          userId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
              table: 'Users',
              key: 'id',
            },
            onUpdate: 'CASCADE',
            onDelete: 'CASCADE',
          },
          categoryId: {
            type: DataTypes.INTEGER,
            allowNull: false,
            references: {
              table: 'Categories',
              key: 'id',
            },
            onUpdate: 'CASCADE',
            onDelete: 'CASCADE',
          },
          amount: {
            type: DataTypes.INTEGER,
            allowNull: false,
          },
          refAmount: {
            type: DataTypes.INTEGER,
            allowNull: false,
          },
          note: {
            type: DataTypes.STRING(100),
            allowNull: true,
          },
        },
        { transaction: t },
      );

      // Add indexes for efficient querying
      await queryInterface.addIndex('TransactionSplits', ['transactionId'], {
        name: 'transaction_splits_transaction_id_idx',
        transaction: t,
      });

      await queryInterface.addIndex('TransactionSplits', ['userId'], {
        name: 'transaction_splits_user_id_idx',
        transaction: t,
      });

      await queryInterface.addIndex('TransactionSplits', ['categoryId'], {
        name: 'transaction_splits_category_id_idx',
        transaction: t,
      });

      await queryInterface.addIndex('TransactionSplits', ['transactionId', 'categoryId'], {
        name: 'transaction_splits_tx_category_idx',
        unique: true,
        transaction: t,
      });

      // Add splitId column to RefundTransactions
      await queryInterface.addColumn(
        'RefundTransactions',
        'splitId',
        {
          type: DataTypes.UUID,
          allowNull: true,
          references: {
            table: 'TransactionSplits',
            key: 'id',
          },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL',
        },
        { transaction: t },
      );

      await queryInterface.addIndex('RefundTransactions', ['splitId'], {
        name: 'refund_transactions_split_id_idx',
        transaction: t,
      });

      await t.commit();
    } catch (error) {
      await t.rollback();
      throw error;
    }
  },

  down: async (queryInterface: AbstractQueryInterface): Promise<void> => {
    const t: Transaction = await queryInterface.sequelize.startUnmanagedTransaction();

    try {
      // Remove splitId from RefundTransactions first (due to FK dependency)
      await queryInterface.removeIndex('RefundTransactions', 'refund_transactions_split_id_idx', {
        transaction: t,
      });
      await queryInterface.removeColumn('RefundTransactions', 'splitId', { transaction: t });

      // Drop TransactionSplits table
      await queryInterface.dropTable('TransactionSplits', { transaction: t });

      await t.commit();
    } catch (error) {
      await t.rollback();
      throw error;
    }
  },
};
